# آرگومان های تابع
متغیر های ورودی ای را که به تابع می دهیم را **formal parameters** می گوییم . این ورودی ها رفتاری شبیه به **local variables** دارند. با اجرای تابع ساخته شده و بعد از پایان یافتن اجرای تابع از بین می روند .

دو راه برای پاس دادن متغیر ها به توابع وجود دارد :

1. **حالت call by value** : در این حالت تابع فضای دیگری در حافظه برای پارامتر درنظر گرفته و مقدار متغیری که به تابع پاس داده شده را عینا در آن کپی کرده و از حافظه جدید استفاده می کند . در این حالت تغییراتی که در تابع روی پارامتر اعمال می شود تاثیری بر روی آرگومان ورودی ندارد .

با یک مثال بیشتر در مورد این موضوع صحبت می کنیم :
```c
#include<stdio.h>

int multiply(int x , int y){

    int z = x * y;

    return z;

}

int main(){

    int a = 2;

    int b = 4;

    int c = multiply(a,b);

    printf("a * b = %d" , c);

    return 0;

}
``` 

اگر این کد را اجرا کنید همچین خروجی خواهید گرفت :
```
a * b = 8
```

این جا بعد از ورود به تابع ، x مقدار متغیر a را می گیرد و مقدار b هم دقیقا در حافظه y کپی می شود . یعنی الان x = 2 , y = 4 . بعد از عمل ضرب متغیر z برابر 8 شده و بعد از پایان یافتن تابع ، متغیر c مقدار دهی شده و خروجی چاپ می شود .

تصویر زیر عملکرد برنامه و حافظه گرفته شده را نشان می دهد :
![حافظه گرفته شده برای متغیر ها](https://www.dropbox.com/scl/fi/dw54bturj20mml3e45n8s/56.png?rlkey=zp0d8ic6dtkwoekioe2wct0l1&st=d2zn4cdl&dl=0)

اگر دقت کنید متوجه می شوید که تغییرات روی x و y تاثیری بر روی متغیر های a و  b  ندارند و در جای دیگری در حافظه قرار دارند . به مثال زیر دقت کنید :
```c
#include<stdio.h>

void change(int x ){
    x = x + 2;
    printf("x = %d \n" , x );
    return;
}

int main(){
    int a = 10;
    change(a);
    printf("a = %d " , a);
    return 0;
}
```

اگر این کد را اجرا کنید خروجی زیر را دریافت خواهید کرد : 
```
x = 12
a = 10 
```

دیدید که مقدار متغیر  a تغییر نکرد. چون بعد از ورود به تابع مقدار a  در x عینا کپی شد و عملیات های بدنه تابع روی متغیر local خود تابع یعنی x انجام شد . در نهایت بعد از تغییر x  به 12 8 تابع پایان یافت و بعد از برگشتن به main دیدیم که متغیر های a  همان مقدار سابق خود یعنی 10 را دارد .


حالا اگر بخواهیم که تابعی داشته باشیم که با آن بتوانیم مقادیر متغیر های دیگر را تغییر بدهیم چطور ؟ 

یک حالت استفاده از   global variable است . آن ها را خارج از توابع و در global scope تعریف کرده و از آن استفاده می کنیم . به طور مثال داریم : 
```c
#include<stdio.h>

int a = 10;

void change(){
    a = a +2;
    printf("      in function a = %d \n" , a );
    return;
}

int main(){
    printf("before call change method a = %d\n" , a );

    change();

    printf("after call change methode a = %d\n" , a );
    return 0;
}
```

با اجرای این کد می توانید خروجی زیر را دریافت کنید :
```c
before call change method a = 10
      in function a = 12 
after call change methode a = 12
```

همان طور که می بینید عملیات بدنه تابع روی مقدار متغیر تاثیر داشت و آن را تغییر داد . 
اما این روش یک مشکل دارد و این است که تمام توابع برنامه به این متغیر دسترسی دارند و این ممکن است برای ما مطلوب نباشد . چگونه تابعی بنویسیم که بتواند بر روی مقدار متغیر تاثیر بگذارد ولی متغیر local در قسمتی از برنامه ؟ 

جواب استفاده از روش **call by refrence** است . برای این کار به جای پاس دادن مقدار متغیر ، آدرس آن را پاس می دهیم که این کار با اشاره گر (pointer) انجام می گیرد که در درسنامه مربوطه یاد خواهید گرفت :)