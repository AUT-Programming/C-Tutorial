# **لینک لیست**

در درسنامه 6.1 با آرایه ها آشنا شدیم و دیدیم که چطور میتوانیم با دانستن تعداد داده هایی که نیاز داریم تا در یک داده ساختار ذخیره کنیم، یک آرایه با اندازه ثابت ایجاد کنیم. اما اگر تعداد داده های ورودی را از قبل ندانیم یا اگر بخواهیم داده جدیدی را به وسط آرایه اضافه کنیم چه باید کنیم؟

در این درسنامه می بینیم که چطور با کمک `pointer` ها و  `struct`  میتوانیم یک داده ساختار جدید ایجاد کنیم که دو ویژگی گفته شده را هم داشته باشند.

برای این کار ابتدا نیاز داریم تا با یک تعریف جدید آشنا شویم:

## گره یا Node

گره ها در لینک لیست درواقع یک مجموعه از داده و اشاره گر است که با استفاده از `struct` گروه میشوند تا به عنوان یک نوع جدید داده استفاده شود.

نمونه ای از ساخت گره با `struct`:

```
struct node {
	 // متفییر برای نگه داری داده (می تواند از هر نوعی باشد)
    int data;
    // اشاره گر به گره بعدی
    struct node* next;
};
```


در اینجا داده زخیره شده ما از نوع `int` است و اشاره گر ما با توجه به نوع آن که `*struct node` است، به یک گره دیگر از همین نوع اشاره میکند.

## لینک لیست چیست؟

لینک لیست یک توالی از گره‌هاست که هر گره شامل یک مقدار داده و یک اشاره‌گر به گره بعدی است. این ساختار به ما اجازه می‌دهد تا برخلاف آرایه‌ها، بدون جابجایی دیگر عناصر، عضوی جدید اضافه کنیم. همچنین، اندازه لینک لیست محدودیتی ندارد.

### مزایای لینک لیست:

1.  **حافظه دینامیک**: اندازه لینک لیست از قبل تعیین نشده و هنگام اضافه کردن گره جدید، فضا به صورت دینامیک تخصیص داده می‌شود.
2.  **افزودن یا حذف آسان**: برخلاف آرایه‌ها، لینک لیست امکان اضافه کردن یا حذف عناصر را به‌راحتی در هر موقعیتی فراهم می‌کند.

## انواع مختلف لینک لیست

بر اساس اینکه گره ایجاد شده توسط ما چند اشاره گر دارد و یا اینکه آخرین عنصر لینک لیست ما به چه چیزی اشاره می کند میتوانیم لینک لیست های مختلفی داشته باشیم. با این توضیخات سه نوع لینک لیست رایج میتوانیم درست کنیم:

* لینک لیست یک طرفه
* لینک لیست دو طرفه
* لینک لیست حلقوی

در ادامه به تعریف و  تحلیل هر یک از این نوع لینک لیست ها و توابع مورد نیاز برای پیاده سازی آنها در زبان C می پردازیم.

## لینک لیست یک طرفه
با گره های بکار رفته در این لینک لیست دربالاتر آشنا شدید که فقط شامل یک متغییر برای داده و یک اشاره گر به گره بعدی بود. در این نوع لینک لیست کافیست تا فقط یک اشاره گر به اولین عضو لیست که تحت عنوان `head` شناخته می شود نیز داشته باشیم.


| ![Lightbox](https://media.geeksforgeeks.org/wp-content/uploads/20240826132228/singly-linked-list-in-c.webp) |
|:--------:|
| *نمونه ای از یک لینک لیست یک طرفه* |


 برای اضافه کردن عضو جدید باید ابتدا یک نمونه از گره مان بسازیم و به آن مقدار بدهیم. سپس می بینیم چطور می توان گره جدید را به لینک لیست مان متصل کنیم.

نمونه کدی از تابعی که یک گره جدید می سازد :
```
#include <stdlib.h>

struct node{
	int data;
	struct node *next;
};

struct node * create_node(int i){
	struct node * nn;
	//تخصیص حافظه به گره جدید
	nn = (struct node *) malloc(sizeof(struct node));

	// بررسی اینکه حافظه درست تخصیص داده شده است یا خیر
	if (nn == NULL)
		return NULL;

	nn->data = i; // مقدار دهی متغییر داده با مفداری که در ورودی گرفتیم
	nn->next = NULL; // گره جدید به طور پیش فرض به هیچ گره دیگری اشاره نمی کند

	return nn;
}
```


در کد زیر چند گره مختلف ایجاد می کنیم و پس از اتصال، آنها را چاپ میکنیم:
```
#include <stdio.h>
#include <stdlib.h>

struct node{
	int data;
	struct node *next;
};

struct node * create_node(int i);

void print_list(struct node *head) {
    struct node *temp = head;
    printf("Linked list values: ");
    while (temp != NULL) { // پیمایش تا زمانی که به انتهای لیست برسیم
        printf("%d -> ", temp->data);
        temp = temp->next; // به گره بعدی می‌رویم
    }
    printf("NULL\n"); // نشان می‌دهیم که به انتهای لیست رسیده‌ایم
}

void clear_link_list(struct node** head){
	// آزاد کردن حافظه تخصیص داده شده
    struct node *current = *head;
    struct node *next;
    while (current != NULL) {
        next = current->next;
        free(current); // آزاد کردن حافظه
        current = next;
    }
}

int main() {
    struct node *list = NULL; //  اشاره‌گر به سر لیست

    // ایجاد گره‌های جدید و لینک کردن آنها
    list = create_node(10);         
    list->next = create_node(20);   
    list->next->next = create_node(30); 

    // چاپ لینک لیست
    print_list(list);

	 // آزاد سازی حافظه گرفته شده بعد اتمام کار
	 clear_link_list(&list);

    return 0;
}
```

----------

خروجی کد:
```
Linked list values: 10 -> 20 -> 30 -> NULL
```


----------
همان طور که دیدید از آنجایی که درون هر گره یک اشاره گر به گره بعدی وجود دارد می توانیم تنها با داشتن گره `head`  می توانیم به گره های بعدی دسترسی داشته باشیم.
>مثلا با دستور `;list->next->next = create_node(30)`  اشاره گر بعدی گره بعدی رو مقدار دهی کردیم  :))

همچنین خیلی مهمه که بعد از اتمام کار با لینک لیست ساخته شده همانند تابعی که در آخر تابع `main` صدا زده شده، حافظه گرفته شده برای آنها از `heap` را آزاد کنیم.

## توابع مورد نیاز
هر داده ساختاری از جمله لینک لیست یک سری رفتار (همون تابع) را باید پیاده سازی کند و نحوه پیاده سازی این توابع هست که کاربرد داده ساختار های مختلف و وجه تمایز آنها را مشخص می کند. حال در ادامه می بینیم که توابع مورد نیاز برای لینک لیست ما چی هستند و چطور میتونیم اونها رو پیاده سازی کنیم.
> در درس ساختمان داده خیلی مفصل تر با لینک لیست و پیاده سازیش آشنا می شین و می بینید که چطور از اون میتونیم برای پیاده سازی داده ساختار های دیگه هم استفاده کنیم.

ساده ترین رفتار هایی که یک لینک لیست باید پیاده سازی کند عبارتند از:
1.  **درج (Insertion)** – یک عنصر را به  لیست اضافه می‌کند.
2.  **حذف (Deletion)** – یک عنصر را از لیست حذف می‌کند.
3.  **نمایش (Display)** – کل لیست را نمایش می‌دهد.
4.  **جستجو (Search)** – یک عنصر را با استفاده از کلید داده شده جستجو می‌کند.
5. **اندازه(Size)** - اندازه ی لیست ایجاد شده را برمی گرداند.

با تابع `print_list` برای نمایش لینک لیست بالاتر آشنا شدید. حالا نحوه درج و حذف عناصر جدید به لیست را هم بررسی میکنیم.

## عملیات درج در لینک لیست

اضافه کردن یک گره جدید به لینک لیست شامل چند مرحله است. در اینجا با استفاده از دیاگرام‌ها این مراحل را یاد می‌گیریم. ابتدا یک گره جدید با استفاده از ساختار مشخص شده ایجاد کرده و محل دقیق درج آن را پیدا می‌کنیم.

### عملیات درج

فرض کنید می‌خواهیم یک گره جدید به نام B (گره جدید) بین گره A (گره سمت چپ) و گره C (گره سمت راست) درج کنیم. ابتدا باید اشاره‌گر B به C تنظیم شود:


![Lightbox](https://www.tutorialspoint.com/data_structures_algorithms/images/insertion_operation.jpg) 

```
NewNode.next -> RightNode;
```


این حالت باید به این شکل دیده شود:

![Lightbox](https://www.tutorialspoint.com/data_structures_algorithms/images/inserting_a_node.jpg) 

حالا اشاره‌گر گره سمت چپ (A) باید به گره جدید (B) اشاره کند.
```
LeftNode.next -> NewNode;
```


این عمل گره جدید را بین دو گره قرار می‌دهد. لیست جدید باید به این شکل دیده شود:

 ![Lightbox](https://www.tutorialspoint.com/data_structures_algorithms/images/point_to_the_new_node.jpg)

درج در لینک لیست وابسته به جایگاهی که میخواهیم به آن عضو جدید اضافه کنیم به سه روش مختلف انجام می‌شود که در ادامه توضیح داده می‌شوند:

### درج در ابتدا لیست
الگوریتم:
1.  یک گره برای ذخیره داده ایجاد کنید
2.  بررسی کنید که آیا لیست خالی است
3.  اگر لیست خالی است، داده را به گره اضافه کرده و اشاره‌گر  `head` را به آن اختصاص دهید
4.  اگر لیست خالی نیست، داده را به یک گره اضافه کنید و آن را به سر فعلی پیوند دهید. سپس اشاره‌گر سر را به گره جدید اضافه شده اختصاص دهید

پیاده سازی تابع:
```
// برای آنکه بتوانیم آدرس را در تابع تغییر بدهیم از اشاره گر به اشاره گر استفاده میکنیم
void insert_at_begin(struct node** head, int data){

   // ساخت یک گره جدید
   struct node *new_node = create_node(data);

   // گره جدید مان به اول لیست باید اشاره کند
   new_node->next = *head;

   // اشاره گر به اول لیست را آپدیت میکنیم
   \*head = new_node;
}
```


نمونه کد ( با قرض اینکه پیاده سازی توابع بعد از `main` تعریف شده):
```
#include <stdio.h>
#include <stdlib.h>

struct node{
    int data;
    struct node *next;
 };

struct node * create_node(int i);
void print_list(struct node *head);
void clear_link_list(struct node** head);
void insert_at_begin(struct node** head, int data);

int main() {
    struct node *list = NULL; //  اشاره‌گر به سر لیست

   // اضافه کردن هر عنصر به اول لیست
	insert_at_begin(&list, 10);
	insert_at_begin(&list, 20);
	insert_at_begin(&list, 30);

    // چاپ لینک لیست
    print_list(list);

	 // آزاد سازی حافظه گرفته شده بعد اتمام کار
    clear_link_list(&list);

    return 0;
}
```


خروجی:
```
Linked list values: 30 -> 20 -> 10 -> NULL
```


### درج در انتها لیست

الگوریتم:
1.  یک گره جدید ایجاد کنید و داده را به آن اختصاص دهید
2.  آخرین گره را پیدا کنید
3.  اشاره‌گر آخرین گره را به گره جدید متصل کنید

پیاده سازی تابع:
```

void insert_at_end(struct node** head, int data){
    // ساخت یک گره جدید   
    struct node *new_node = create_node(data);

	// اگر لیست خالی است
    if (*head == NULL) {
        \*head = new_node;
        return;
    }

	 // اگر لیست خالی نبود آنقدر در لیست پیش میرویم تا به آخر برسیم
	 struct node *linked_list = *head;
    while(linked_list->next != NULL)
            linked_list = linked_list->next;

    // گره جدید را در انتها لیست قبلی میگذاریم
    linked_list->next = new_node;
 }
```


نمونه کد ( با قرض اینکه پیاده سازی توابع بعد از `main` تعریف شده):
```
#include <stdio.h>
#include <stdlib.h>

struct node{
    int data;
    struct node *next;
 };

struct node * create_node(int i);
void print_list(struct node *head);
void clear_link_list(struct node** head);
void insert_at_begin(struct node** head, int data);
void insert_at_end(struct node** head, int data);

int main() {
    struct node *list = NULL; //  اشاره‌گر به سر لیست

   // اضافه کردن هر عنصر به اول لیست
	insert_at_end(&list, 30);
	insert_at_begin(&list, 10);
	insert_at_begin(&list, 20);
	insert_at_end(&list, 40);

    // چاپ لینک لیست
    print_list(list);

	 // آزاد سازی حافظه گرفته شده بعد اتمام کار
    clear_link_list(&list);

    return 0;
}
```


خروجی:
```
Linked list values: 20 -> 10 -> 30 -> 40 -> NULL
```


* توجه کنید که اگر همانند اشاره گر به اول لیست، یک اشاره گر به آخر لیست به اسم `tail` داشتیم میتوانستیم همانند تابع `insert_at_begin` بدون استفاده از حلقه و سریع تر به آخر لیست عضو اضافه کنیم.
* همچنین اگر شرط حلقه `while` را تغییر دهیم میتوانیم تابعی برای اضافه کردن گره بعد از عنصری خاص در وسط لیست ایجاد کنیم.

## حذف از لیست
عمل حذف نیز یک فرآیند چند مرحله‌ای است. این فرآیند را با نمایش تصویری یاد می‌گیریم. ابتدا، گره هدفی را که قرار است حذف شود، با استفاده از الگوریتم‌های جستجو پیدا کنید.

 ![Lightbox](https://www.tutorialspoint.com/data_structures_algorithms/images/deletion_operation.jpg) 

گره سمت چپ (قبلی) گره هدف اکنون باید به گره بعدی گره هدف اشاره کند:
```
LeftNode.next -> TargetNode.next;
```


 ![Lightbox](https://www.tutorialspoint.com/data_structures_algorithms/images/linked_list_deletion.jpg) 

این کار پیوندی را که به گره هدف اشاره می‌کرد، حذف خواهد کرد. حالا، با استفاده از کد زیر، اشاره‌گر گره هدف را به `NULL` تنظیم می‌کنیم:
```
TargetNode.next -> NULL;
```


 ![Lightbox](https://www.tutorialspoint.com/data_structures_algorithms/images/pointing_target_node.jpg) 

ما می‌توانیم از داده‌های گره حذف شده استفاده کنیم، یا اینکه می‌توانیم حافظه را آزاد کرده و گره هدف را کاملاً پاک کنیم.

 ![Lightbox](https://www.tutorialspoint.com/data_structures_algorithms/images/use_deleted_node.jpg) 

![Lightbox](https://www.tutorialspoint.com/data_structures_algorithms/images/data_items.jpg) 


مراحل مشابهی باید انجام شود اگر گره در ابتدای لیست وارد شود. هنگام افزودن گره به انتهای لیست، گره ماقبل آخر باید به گره جدید اشاره کند و گره جدید به `NULL` اشاره کند.

### حذف از ابتدا یا انتها لیست
پیاده سازی توابع حذف از ابتدا و یا انتها لیست به شکل زیر است:
```
#include <stdlib.h>

void delete_at_begin(struct node **head) {
// اگر لیست خالی است، نیازی به حذف نیست
    if (*head == NULL) {
        return;
    }

    struct node *copy_of_head = *head;
    \*head = (*head)->next;
    free(copy_of_head);
}

void delete_at_end(struct node** head) {
    // اگر لیست خالی است، نیازی به حذف نیست
    if (*head == NULL) {
        return;
    }

    // اگر لیست فقط یک گره دارد
    if ((*head)->next == NULL) {
        free(*head);
        \*head = NULL;
        return;
    }

    // اگر لیست بیش از یک گره دارد
    struct node *linkedlist = *head;
    while (linkedlist->next->next != NULL) {
        linkedlist = linkedlist->next;
    }

    struct node *last_node = linkedlist->next;
    linkedlist->next = NULL;
    free(last_node);
}
```

### حذف یک گره با مقدار خاص

پیاده سازی تابع:
```
#include <stdlib.h>

void deletenode(struct node** head, int key) {
    struct node *temp = *head;

    // اگر گره اول شامل کلید مورد نظر باشد
    if (temp != NULL && temp->data == key) {
        \*head = temp->next;  // سر را به گره بعدی منتقل کنید
        free(temp);  // آزاد کردن حافظه گره حذف شده
        return;
    }

    // جستجوی گره‌ای که کلید را دارد
    struct node *prev = NULL;
    while (temp != NULL && temp->data != key) {
        prev = temp;
        temp = temp->next;
    }

    // اگر کلید در لیست موجود نباشد
    if (temp == NULL) return;

    // جدا کردن گره از لیست پیوندی
    prev->next = temp->next;

    // آزاد کردن حافظه گره حذف شده
    free(temp);
}

```

نمونه کاربرد در کد:
```
#include <stdio.h>
#include <stdlib.h>

struct node{
    int data;
    struct node *next;
 };

struct node * create_node(int i);
void print_list(struct node *head);
void clear_link_list(struct node** head);
void insert_at_begin(struct node** head, int data);
void insert_at_end(struct node** head, int data);
void delete_at_begin(struct node **head);
void delete_at_end(struct node** head);
void deletenode(struct node** head, int key);

int main() {
   struct node *list = NULL; //  اشاره‌گر به سر لیست

   // اضافه کردن هر عنصر به اول لیست
	insert_at_end(&list, 30);
	insert_at_begin(&list, 10);
	insert_at_end(&list, 50);
	insert_at_begin(&list, 20);
	insert_at_end(&list, 40);
	print_list(list);

	// حذف عنصر اول
	deleteatbegin(&list);
	print_list(list);

	// حذف عنصر آخر
	deleteatend(&list);
	print_list(list);

	// حذف عنصر با مقدار 30
	deletenode(&list, 30);
	print_list(list);

	// آزاد سازی حافظه گرفته شده بعد اتمام کار
   clear_link_list(&list);

   return 0;
}
```

خروجی:
```
Linked list values: 20 -> 10 -> 30 -> 50 -> 40 -> NULL
Linked list values: 10 -> 30 -> 50 -> 40 -> NULL
Linked list values: 10 -> 30 -> 50 -> NULL
Linked list values: 10 -> 50 -> NULL
```

## جست و جو یک عنصر خاص
تابع زیر در صورت وجود یک داده خاص در لینک لیست مقدار `1` یا `true` برمیگرداند در غیر اینصورت `0` یا `false` برمیگرداند:
```
int searchlist(struct node** head, int key){
   struct node *temp = *head;
   while(temp != NULL) {
      if (temp->data == key) {
         return 1;
      }
      temp=temp->next;
   }
   return 0;
}
```

## لینک لیست دو طرفه
لیست پیوندی دوطرفه کمی پیچیده‌تر از لیست پیوندی یک‌طرفه است. در این نوع لیست، هر گره شامل سه بخش است: داده، یک اشاره‌گر به گره بعدی و یک اشاره‌گر اضافی که به گره قبلی اشاره می‌کند. این ساختار امکان پیمایش در هر دو جهت را فراهم می‌کند و آن را نسبت به لیست پیوندی یک‌طرفه انعطاف‌پذیرتر می‌سازد.

 ![Lightbox](https://media.geeksforgeeks.org/wp-content/uploads/20240826130046/doubly-linked-list-in-c.webp) 


یک لیست پیوندی دوطرفه به عنوان یک اشاره‌گر به اولین گره (`head`) نمایش داده می‌شود، به طوری که هر گره شامل موارد زیر است:
* __داده__: اطلاعات اصلی ذخیره شده در گره.
* __بعدی__: اشاره‌گری که به گره بعدی در توالی اشاره می‌کند.
* __قبلی__: اشاره‌گری که به گره قبلی در توالی اشاره می‌کند.

نمونه گره در لینک لیست دوطرفه:
```
struct node {
	 // متفییر برای نگه داری داده (می تواند از هر نوعی باشد)
    int data;
    // اشاره گر به گره بعدی
    struct node* next;
    // اشاره گر به گره قبلی
    struct node* prev;
};
```

واضحا توابع لینک لیست یک طرفه برای لیست دوطرفه نیز قابل استفاده اند و حتی با کمی تغییر میتوانند کاربری بیشتری و آسان تری در لیست های دوطرفه داشته باشند.
> سعی کنید خودتون توابع لیست یک طرفه رو دستکاری کنید تا در لیست دوطرفه و در جهت عکس هم قابل استفاده باشه :)

## لینک لیست حلقوی 
لیست پیوندی حلقوی یک نوع تغییر یافته از لیست پیوندی یک‌طرفه است که در آن گره آخر به گره اول اشاره می‌کند و یک حلقه تشکیل می‌دهد. این به این معناست که در انتها هیچ مقدار `NULL` وجود ندارد و لیست می‌تواند به صورت حلقوی پیمایش شود.

 ![Lightbox](https://media.geeksforgeeks.org/wp-content/uploads/20240826132256/Circular-linked-list-in-c.webp) |


ساختار گره در لیست پیوندی حلقوی مشابه ساختار لیست پیوندی یک‌طرفه است.
>هرچند میتوان آنرا با گره های لیست دو طرفه نیز پیاده سازی کرد تا در حلقه مان در آزادی عمل بیشتری داشته باشیم

یک لیست پیوندی حلقوی به عنوان یک اشاره‌گر به اولین گره نمایش داده می‌شود، به طوری که هر گره شامل موارد زیر است:
* __داده__: اطلاعات اصلی ذخیره شده در گره.
* __بعدی__: اشاره‌گری که به گره بعدی پیوند دارد و در گره آخر به گره اول اشاره می‌کند.

----------

## چکیده و مرور

### کاربردها و مزایای لیست پیوندی در زبان C
+ **کاربردها**: تخصیص و مدیریت پویا حافظه، پیاده‌سازی ساختارهای داده‌ای مانند پشته و صف، نمایش چندجمله‌ای‌ها و استفاده در سیستم‌های فایل.
+ **مزایا**: تغییر اندازه پویا، درج و حذف کارآمد گره‌ها بدون نیاز به جابجایی، استفاده بهینه از حافظه، و مناسب برای حافظه‌های پراکنده.

### معایب لیست پیوندی
+ نیاز به حافظه اضافی برای اشاره‌گرها
+ دسترسی غیرمستقیم و زمان‌بر به عناصر
+ مدیریت پیچیده‌تر اشاره‌گرها و عملکرد کندتر نسبت به آرایه‌ها در برخی کاربردها

### سوالات متداول در مورد لیست پیوندی

+ **لیست پیوندی چیست؟** یک ساختار داده که هر گره آن داده و اشاره‌گری به گره بعدی را شامل می‌شود.
+ **تفاوت لیست پیوندی و آرایه چیست؟** لیست پیوندی عناصر را غیربه‌هم‌پیوسته ذخیره و از تخصیص پویا استفاده می‌کند، در حالی که آرایه‌ها به‌صورت به‌هم‌پیوسته و با اندازه ثابت هستند.
+ **انواع اصلی لیست‌های پیوندی چیست؟** لیست یک‌طرفه، دوطرفه و حلقوی.
+ **چرا لیست پیوندی به‌جای آرایه؟** به دلیل تغییر اندازه پویا، درج و حذف آسان‌تر و کارایی حافظه در داده‌های نامعلوم.
+ **محدودیت‌های لیست پیوندی چیست؟** حافظه بیشتر، نداشتن دسترسی مستقیم، پیچیدگی پیاده‌سازی و عملکرد ضعیف‌تر حافظه کش.
+ **کاربردهای واقعی لیست پیوندی چیست؟** استفاده در مدیریت حافظه پویا، پیاده‌سازی پشته و صف، مدیریت سیستم فایل و نمایش چندجمله‌ای‌ها.
